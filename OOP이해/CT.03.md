# 객체 지향의 4대 특성
<br>

## 객체 지향의 4대 특성
- 캡슐화(Encapsulation) : 정보 은닉(information hiding)
- 상속 : 재사용
- 추상화(Abstraction) : 모델링
- 다형성(Polymorphism) : 사용 편의
<br>

## 클래스 vs 객체
- 클래스와 객체의 관계는 붕어빵틀과 붕어빵이 아니다
  - 이를 코드로 나타내면 `금형기계 붕어빵틀 = new 금형기계();`, 한국어로 번역해 보면 `새로운 금형기계를 하나 만들었더니 붕어빵틀이 되었다` 이해X
- 클래스와 객체를 구분을 쉽게 하는법 사람과 김연아를 예제로 했을 때 나이가 몇인가? 를 물으면 된다
  - 사람 : 나이를 알 수 없음 (클래스) 
  - 김연아 : 나이를 알 수 있음 (객체)
- 클래스는 분류에 대한 개념
- 객체는 실체
<br>

## 추상화
- 객체 지향의 추상화는 곧 모델링이다
- 추상화란 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재 조합하는 것 (모델링)
<br>

## 클래스 멤버 vs 객체 멤버
### 클래스 멤버
- static 키워드가 붙은 속성을 클래스 멤버 속성이라고 한다
- 객체 모두가 같은 값을 갖는 속성일 경우 클래스 멤버로 지정하는 것이 좋다
- 스태틱 영역에 클래스가 배치될 때 클래스 내부에 메모리 공간이 확보된다
- 초기화를 해주지 않아도 정수형은 0, 부동소수점형은 0.0, 논리형은 false, 객체는 null로 초기화 된다
<br>

> 클래스 멤버 = static 멤버 = 정적 멤버
> 객체 멤버 = 인스턴스 멤버

<br>

### 클래스 멤버를 사용하는 경우
- main() 메소드의 논리를 함수로 분할해서 사용하는 경우
- 정적 변수에 대한 getter, setter 메소드로 사용하는 용도
- 클래스의 인스턴스를 만들지 않고 사용하게 되는 유틸리티성 메소드

> UML 표기법에서 정적 멤버에 대해서는 밑줄을 사용해 표시한다
<br>

## 세 가지 변수 유형
|이름 | 사는곳 |
|---| -----| 
| static 변수 | 스태틱 영역 |
| 인스턴스 변수 | 힙 영역 |
| local 변수 | 스택 영역(스택 프레임 내부) |
<br>

## 상속 : 재사용 + 확장
- 객체지향의 상속은 상속이 아닌 `재사용`과 `확장`으로 이해해야 한다
  - inheritance(상속)은 존재하지 않고, extend(확장)이 존재한다
- 부모 클래스 - 자식 클래스라는 표현보다 `상위 클래스 - 하위 클래스` 또는 `슈퍼 클래스 - 서브 클래스`라고 표현하자
- 상위 클래스 쪽으로 갈수록 추상화, 일반화 됐다고 하며
- 하위 클래스 쪽으로 갈수록 구체화, 특수화 됐다고 한다

<br>

### 상속 관계에 반드시 만족해야 할 문장
- `하위 클래스는 상위 클래스다`
- LSP(리스코프 치환 원칙)을 나타내는 말이다
<br>

### 상속의 관계 표현
- is a 관계로 표현하기 보단
- `is a kind of` 로 표현한다
<br>

#### 예시
- is a 관계 : 펭귄 is a 조류 -> 펭귄은 한 마리 조류이다
- is a kind of : 펭귄 is a kind of 조류 -> 펭귄은 조류의 한 분류이다
<br>

> is a kind of 관계가 사람 말로 해석했을때 더 이해하기 쉽다

<br>

### 상속 정리
- 객체 지향의 상속은 상위 클래스의 특성을 `재사용` 하는 것
- 객체 지향의 상속은 상위 클래스의 특성을 `확장`하는 것
- 객체 지향의 상속은 `is a kind of` 관계를 만족해야 한다
<br>

## 다중 상속
자바는 인터페이스를 도입해 다중 상속의 득은 취하고 실은 버렸다
<br>

### 인터페이스의 관계 표현
- 구현 클래스 is able to 인터페이스
- 해석 : 구현 클래스는 인터페이스할 수 있다
<br>

#### 자바에서의 예시
- Serializable 인터페이스 : 직렬화할 수 있는
- Runnable 인터페이스 : 실행할 수 있는

> 상위 클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메소드의 개수가 적을수록 좋다

<br>

### 상속과 T 메모리
- 하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다
<br>

## 다형성 : 사용편의성
- 객체 지향에서 다형성은 오버라이딩(overriding)과 오버로딩(overloading)이라고 할 수 있다
<br>

### 오버라이딩과 오버로딩
- 오버라이딩 : 같은 메소드 이름, 같은 인자 목록으로 상위 클래스의 메소드를 재정의
- 오버로딩 : 같은 메소드 이름, 다른 인자 목록으로 다수의 메소드를 중복 정의

> 메소드 호출시 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메소드가 호출된다
<br>

## 참조 변수의 복사
### Call By Value VS Call By Reference 
- Call By Value와 Call By Reference는 차이가 없다
- 차이라면 `기본 자료형 변수`는 `저장하고 있는 값을 그 값 자체로 해석`하고
- `객체 참조 변수`는 `저장하고 있는 값을 주소로 해석`한다
<br>


